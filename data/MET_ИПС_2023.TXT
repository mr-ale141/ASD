
            СТРУКТУРЫ И АЛГОРИТМЫ ОБРАБОТКИ ДАННЫХ

          2. ВАРИАНТЫ ЗАДАНИЙ ДЛЯ ЛАБОРАТОРНЫХ РАБОТ

                    2.2. Линейные списки

   Общими требованиями к лабораторной работе являются:
   1) организовать  ввод  данных  из  файла  в   понятной  для 
пользователя форме;
   2) обеспечить   возможность   многократных   запросов   без
повторного запуска программы;
   3) при реализации в С++ не использовать контейнерные классы
для работы с линейными списками типа stack, queue и т. п.

   1. Автомобильная  стоянка  вмещает  N  машин  и  имеет одну
полосу с единственным въездом-выездом.  Если владелец приходит
за  машиной,  временно  выезжают и потом возвращаются в том же
порядке  все  машины,  загораживающие  проезд.  Если   стоянка
заполнена,     то    прибывшая    машина    уезжает.    Задана
последовательность номеров машин  с  признаками  прибытия  или
убытия.  Составить  протокол работы стоянки,  сообщая обо всех
событиях (6).

   2. Автостоянка содержит одну полосу,  на которой может быть
размещено до N машин.  Имеется план прибытия и убытия машин на
стоянку.  Если  в момент прибытия стоянка оказывается занятой,
машина уезжает восвояси.  Машины въезжают с южной  стороны,  а
могут  выехать  из K (K<N) крайних мест северной стороны.  При
выезде машины очередь сдвигается с юга на север. Требуется:
   1) промоделировать работу стоянки,  последовательно сообщая
о приходе и  убытии  машин  с  выдачей  информации  о  стоящих
машинах;
   2) выдать два списка номеров машин:  тех, которые не смогли
встать на стоянку, и тех, что не смогли выехать вовремя (6).

   3. Составить  программу  работы  с  циклической   очередью,
организованной   с   помощью   массива.   Обеспечить  операции
постановки в очередь,  продвижения очереди, вставки в середину
после элемента с заданным ключом и удаления из середины (6).

   4. Два стека размещены в одном массиве и  растут  навстречу
друг  другу.  Задана  последовательность операций размещения и
удаления  элементов  с  указанием  номера  стека.   Обеспечить
выполнение  данных  операций  и  обработку аварийных ситуаций.
Сообщить в конце:
   1) какой  минимальный  резерв  памяти оставался в массиве в
процессе выполнения операций;
   2) какой  интервал  индексов  массива  не использовался для
размещения элементов (6).

   5. Две очереди размещены в одном массиве и растут навстречу
друг другу.  Задана последовательность операций  размещения  и
удаления  элементов  с  указанием  номера очереди.  Обеспечить
выполнение данных операций  и  обработку  аварийных  ситуаций.
Сообщить в конце:
   1) какой минимальный резерв памяти оставался  в  массиве  в
процессе выполнения операций;
   2) какой интервал индексов  массива  не  использовался  для
размещения элементов (6).

   6. Задания  для   выполнения  на компьютере имеют различные
приоритеты, задаваемые цифрами от 1 до 5 (5-высший приоритет).
Для каждого приоритета образуется отдельная очередь. Приоритет
задания  может  меняться.  При  повышении  приоритета  задание
помещается в конец другой очереди, а при понижении - в начало.
Составить программу, обеспечивающую:
   1) выдачу общей очереди;
   2) выдачу очереди заданного приоритета;
   3) перестройку очередей при изменении приоритета (7).

   7. Перед открытием двух железнодорожных касс сформировались
2 очереди пассажиров,  причем некоторые из них находятся сразу
в  обеих очередях.  Для каждого пассажира известны его места в
очередях и необходимое время обслуживания.  Если у какого-либо
пассажира очереди подходят одновременно, то он обслуживается в
первой   кассе.   Промоделировать   работу    касс,    выдавая
последовательно информацию об обслуживании пассажиров (7).

   8. Выборы  старосты  в  группе  студентов  из   M   человек
организованы  по следующим правилам.  Задаются целые числа N и
K.  Студенты становятся по  кругу  в  соответствии  со  своими
номерами в журнале. Начиная от N-го студента отсчитывается K-й
студент.  Счет ведется циклически по возрастанию номеров. Этот
студент   выбывает  из  претендентов.  Начиная  со  следующего
студента,  процедура повторяется. Последний оставшийся студент
становится старостой.  Ввести значения M,  N,  K и найти номер
старосты (7).

   9. В   символьной  строке  записано  выражение  из  букв  и
операций в постфиксной форме (знак операции  после операндов).
Проверить   правильность   записи   и  перевести  выражение  в
инфиксную (обычную)  форму  со  скобками. Например,  выражение
(a+b)*c-d*e  записывается  в постфиксной форме как  ab+c*de*-.
Требуется выдать его в виде (((a+b)*c)-(d*e)) (7).

   10. В  символьной  строке  записано  выражение  из  букв  и
операций в префиксной форме (знак операции  перед операндами).
Проверить   правильность   записи   и  перевести  выражение  в
постфиксную форму (знак операции после операндов). При наличии 
ошибок указать место одной из них.
   Пример: выражение  (a+b)*c-d*e  записывается  в  префиксной
форме как -*+abc*de. Требуется выдать его в виде ab+c*de*-(7).

   11. В  символьной  строке  записано  выражение  из  цифр  и
операций в постфиксной форме (знак операции  после операндов).
Проверить правильность записи и найти значение  выражения. При 
наличии ошибок указать место первой из них.
   Пример: выражение (2+3)*4-5*6  записывается  в  постфиксной
форме как 23+4*56*- (7).

   12. Имеется кольцевая очередь,  заданная массивом, и  стек,
заданный с помощью указателей.  Информационная часть элементов
обеих  структур  идентична.  Обеспечить   операции  включения,
удаления, выдачи элементов  стека  и  очереди.  По  требованию
пользователя исключить из стека элементы, имеющиеся в  очереди
(7).

   13. В   некотором   институте   приобретаемые    компьютеры
выделяются   различным   факультетам  поочередно.  В  пределах
факультетов имеются очереди из кафедр.  Факультет,  получивший
компьютер,  перемещается  в  конец очереди,  а соответствующая
кафедра   исключается   из   факультетской   очереди.    Вновь
организованные факультеты и кафедры занимают последние места в
соответствующих очередях.  Составить программу ведения очереди
на компьютеры (8).

   14. Данные  о  студенческих  группах  записаны  в  файле  в
следующем виде:
              ----------------------------------
              ¦ Информация ¦  Факультет ¦ Курс ¦
              ¦ о группе   ¦            ¦      ¦
              ----------------------------------
   Организовать с  помощью  указателей  размещение  списка   с
данными о группах в основной памяти так,  чтобы каждый элемент
располагался один раз.  Составить программу выдачи всех  групп
заданного  факультета  либо  заданного курса без перебора всех
элементов (8).

   15. Трассировка  программы,   не   содержащей   рекурсивных
вызовов  и  повторяющихся  имен  процедур,  распечатана в виде
списка выполняемых процедур. Процедура попадает в список, если
к ней произошло обращение из вызывающей процедуры либо возврат
управления из  вызванной  ей  процедуры.  Структура  программы
такова,  что  каждая вызываемая процедура вложена в вызывающую
ее процедуру.  Известен объем памяти,  который  требуется  для
загрузки каждой процедуры.  При выходе из процедуры занимаемая
ей   память   освобождается.   Выяснить,   соответствует    ли
трассировка  правильной  работе  программы.  Определить размер
памяти,  необходимый для работы программы,  и цепочку вызовов,
требующую максимальной памяти (8).

   16. У множества шпионов,  собравшихся вместе для наблюдения
секретного     объекта,    имеется    единственный    бинокль.
Сформировалась очередь на этот  бинокль.  Для  каждого  шпиона
задан   период   наблюдения   в  минутах  и  предельное  время
нахождения в очереди. После наблюдения каждый шпион становится
снова  в  конец  очереди.  Как  только  для какого-либо шпиона
истекает предельное время нахождения в очереди, он покидает ее
(даже  если  в  этот момент владеет биноклем) и отправляется к
резиденту. Вывести протокол наблюдения шпионов за объектом(9).

   17. На   узловой   станции  необходимо  менять  направления
движения всех  поездов.  Для  этого  предназначен  специальный
тупик.  Зашедший  в  тупик  последний  поезд  выходит  из него
первым.  Известны  моменты  прихода   поездов   и   минимально
необходимое   время   стоянки (одинаковое  для всех  поездов).
Требуется:
   1) составить расписание стоянки поездов на станции с учетом
смены направления движения;
   2) поменять   между   собой   моменты   прихода   скорых  и
пассажирских  поездов   так,   чтобы   скорые   поезда   имели
минимальное суммарное время простоя в тупике (9).

   18. Организовать  в  основной  памяти с помощью указателей
стек из очередей. Обеспечить   операции   ведения  очереди из
вершины   стека,   расширения   и  сокращения  стека,  выдачи 
содержимого стека (9).

   19. Организовать  в основной  памяти  с помощью указателей
очередь  из  стеков. Обеспечить  операции  ведения  стека  из
начала  очереди, дополнения  и  продвижения  очереди,  выдачи
содержимого очереди (9).

   20. Текст программы на диалекте бейсика включает циклы вида
FOR ID=
 ...............
 ...............
NEXT  ID  ,
где ID-идентификатор параметра цикла.
Требуется:
   1) проверить   правильность    идентификаторов,    задающих
параметры  циклов (не более двух символов;  первый - латинская
буква, а второй, если он имеется, - цифра);
   2) с   помощью  стека  проверить  правильность  вложенности
циклов;
   3) переписать файл с исходным текстом так,  чтобы операторы
цикла каждого последующего уровня вложения  были  сдвинуты  на
две позиции вправо по сравнению с предыдущим уровнем (9).

   21. Учебный план включает перечень дисциплин.  Задан список
пар   дисциплин.   Отдельная   пара   показывает,  что  вторая
дисциплина должна изучаться  после  первой.  Составить  список
дисциплин учебного плана в порядке их изучения.  В том случае,
когда задание некорректно,  т.е.  в списке пар имеются  циклы,
выдать хотя бы один из них (10).

   22. В   некотором   компиляторе   ПАСКАЛя  текст  программы
включает примечания,  выделенные  фигурными  скобками  '{','}'
либо  парами  символов  '(*'  и  '*)'.  Примечания  могут быть
вложенными друг в друга.  Если примечание открыто знаком  '{',
то оно должно быть закрыто знаком '}'.  Аналогично примечание,
начинающееся с символов '(*'  должно  заканчиваться  символами
'*)'. Требуется:
   1) проверить правильность вложенности примечаний;
   2) переписать   файл   с   исходным   текстом   так,  чтобы
отсутствовала  вложенность  комментариев  при  сохранении   их
содержания  и  в  качестве  ограничивающих  символов  остались
только  фигурные  скобки.   Учесть   случай,   когда   символы
примечаний находятся в апострофах. При некорректности  указать 
номера строки и позиции первой ошибки (10).

   23. В строке текстового файла  задано  выражение  из  целых 
чисел и операций '+', '-', '*', '/', '^'.  Порядок  вычислений 
определяется приоритетом операций и круглыми скобками. Возможен
одноместный минус в начале  выражения  или  после  открывающей 
скобки. Преобразовать выражение в постфиксную  форму (алгоритм 
Дейкстры) и вычислить его значение. Показать этапы  выполнения
(11).

   24. Имеется  выражение  в  постфиксной  форме,   включающее 
обращение к функциям SIN, COS, EXP.  Переменные  заданы  одной 
строчной латинской буквой.  Запросить  значения  переменных  и 
вычислить выражение. Представить  его  в  инфиксной  форме  со 
скобками. Лишние скобки присутствовать не должны (11).

   25. Программа  на ПАСКАЛЕ включает такие сочетания ключевых
слов, как  REPEAT..UNTIL, RECORD..END, CASE..END и BEGIN..END.
Некоторые части программы могут быть  закомментированы, другие
части текста могут представлять собой  константы в апострофах.
Требуется проверить правильность вложенности этих  конструкций
с  учетом  допустимости  взаимных  вложений.  В случае  ошибок
указать номер первой некорректной строки (11).

                         2.3. Деревья

   Общими требованиями к лабораторной работе являются:
   1) вводить   исходное   дерево  из  файла  в  понятной  для
пользователя форме, а не с клавиатуры;
   2) по требованию прользователя показывать дерево на экране;
   3) обрабатывать  дерево  в  оперативной памяти,  а не путем
многократного обращения к файлу;
   4) обеспечить   возможность   многократных   запросов   без
повторного запуска программы.

   1. Изделие задано  с  помощью  дерева.  В  листьях  указаны
значения  массы  соответствующих деталей.  Масса сборного узла
определяется как сумма масс составляющих деталей. Требуется:
   1) рассчитать массу всего изделия;
   2) организовать  обход  листьев,  запрашивая новые значения
массы и сообщая, как при этом меняется масса изделия (8).

   2. Ввести  произвольное  сильно  ветвящееся дерево.  Выдать
списки вершин:
   1) являющихся листьями;
   2) не являющихся листьями;
   3) родителей листьев;
   4) заданного уровня, считая от вершины (8).

   3. В    листьях    дерева,    соответствующего    некоторой
конструкции,  указаны  минимально  возможные  значения  массы.
Задана   предельно  допустимая  масса  конструкции.  Требуется
определить максимально возможное  значение  массы  для  каждой
вершины дерева (8).

   4. В    листьях    дерева,    соответствующего    некоторой
конструкции,  указаны  значения  массы.  Масса  сборного  узла
определяется как сумма масс  составляющих  деталей.  Требуется
определить  значение  массы  для каждого узла конструкции,  не
превосходящего заданного уровня от вершины дерева (9).

   5. Имеется дерево, корень которого соответствует основателю
рода.  Сыновья  каждой  вершины  задают  сыновей   и   дочерей
соответствующего    человека.   Указывается   имя   некоторого
человека.  Требуется выдать имена его детей,  внуков, сестер и
братьев, одного из родителей, дедушки или бабушки (9).

   6. Имеются  две  статьи.  Каждая  из  них  включает  список
источников.  В  них в свою очередь могут быть ссылки на другие
источники.  Известны год и месяц опубликования каждой  статьи.
Проверить  корректность  ввода  информации.  Определить  общие
источники двух статей, начиная с заданного года (9).

   7. Теннисный  турнир  проходит  по  олимпийской  системе  с
выбываниями. В турнире участвуют 2^n игроков. Известен рейтинг
каждого игрока.  Результаты турнира записаны с помощью дерева.
Сенсацией считается выигрыш игрока с меньшим рейтингом. Выдать
список всех сенсаций турнира с указанием номера тура,  а также
главные сенсации, которые определяется  максимальной  разницей
рейтингов (9). 

   8. Структура  некоторого института задана деревом. Сыновьям
корневой вершины соответствуют факультеты,  факультеты в  свою
очередь  делятся  на  кафедры,  которые  могут  иметь филиалы.
Листьям   дерева    соответствуют    преподаватели.    Выявить
преподавателей, ведущих занятия на трех и более кафедрах (10).

   9. Задано  сильно ветвящееся дерево. При  его  вводе  могли
быть  сделаны ошибки.  Провести проверку на отсутствие циклов,
то есть повторяющихся вершин.  При обнаружении цикла выдать на
экран последовательность вершин, составляющих цикл (10).

   10. Имеется план школьного сочинения, записанный с  помощью
дерева.  Два друга решили написать сочинение вместе. Каждый из
них независимо  взял  несколько  частей,  задавая  их  корнями
соответствующих    поддеревьев.    Требуется    выдать    план
неохваченной части сочинения (10).

   11. Имеется   дерево,   корень    которого    соответствует
основателю  рода.  Сыновья  каждой  вершины  задают  сыновей и
дочерей  соответствующего  человека.  Указываются  имена  двух
человек  (например,  А  и  В).  Сообщить,  какая  из следующих
ситуаций имеет место:
   1) А предок В;
   2) В предок А;
   3) А и В имеют ближайшего общего предка С (10).

   12. Имеется  дерево  вызовов  процедур некоторой программы.
Структура программы такова,  что каждая  вызываемая  процедура
вложена в вызывающую ее процедуру. Задан объем памяти, который
требуется  для  загрузки  каждой  процедуры.  При  выходе   из
процедуры  занимаемая ей память освобождается.  Известно,  что
вызов процедур  при  работе  программы  соответствовал  обходу
дерева  в  порядке  сверху вниз.  Дать трассировку программы в
виде списка вызываемых процедур.  Процедура должна попадать  в
список, если к ней произошло обращение из вызывающей процедуры
либо возврат управления из вызванной ей  процедуры. Определить
размер  памяти,  необходимый  для работы программы,  и цепочку
вызовов, требующую максимальной памяти (10).

   13. В   некотором   институте   информация   об   имеющихся
компьютерах  задана   деревом.   Сыновьям   корневой   вершины 
соответствуют факультеты,  факультеты в  свою очередь  делятся
на  кафедры, кафедры  могут иметь в своем составе лаборатории. 
Компьютеры могут быть установлены в общих факультетских классах,
на кафедрах,  в  лабораториях  и идентифицируются  уникальными 
номерами. Требуется найти:
 1) факультеты с минимальным и максимальным числом компьютеров;
 2) кафедры с минимальным и максимальным числом компьютеров(11).

   14. В  листьях  бинарного  дерева  указаны   идентификаторы
переменных,  в других вершинах - знаки арифметических операций
или функции SIN,  COS, TG, CTG, LOG, EXP. Возможны одноместные
операции типа '+' или '-'. В этом случае требуется только один
операнд.    Значения    переменных     известны.     Проверить
синтаксическую  правильность идентификаторов.  Выдать на экран
выражение в инфиксной форме со  скобками. Запросить в  диалоге
значения переменных и определить результат вычисления выражения.
   Пример: ((-(((a1*bar)+c))-(((SIN(dors))-e)))) (11).

   15. Задано бинарное  дерево.  Построить  прошитое   дерево,
соответствующее обходу сверху вниз. Составить программу удале-
ния поддерева с  корнем  в  заданной  вершине  без  повторного
построения дерева. Конечное дерево должно оставаться прошитым. 
Выдать информацию о нитях исходного и конечного деревьев (12).

   16. Теннисный  турнир  проходит  по  олимпийской  системе с
выбываниями. В турнире участвуют 2^n игроков. Известен рейтинг
каждого игрока. Чем больше рейтинг, тем выше мастерство игрока.
В первом туре сильнейший игрок встречается со слабейшим, второй
по рейтингу с предпоследним и т. д. Организаторы собираются и в
дальнейшем  придерживаться  этого  принципа, предполагая, что в
очередной  тур  будет  выходить  сильнейшая  половина   игроков
предыдущего  тура.  Известно,  что  турнир  прошел   в   полном 
соответствии с рейтингом игроков. Требуется показать в наглядном
виде дерево проведенного турнира (12).

   17. В   некотором   институте   информация   об   имеющихся
компьютерах  задана двумя деревьями.  В первом из них сыновьям
корневой вершины соответствуют факультеты,  факультеты в  свою
очередь  делятся  на  кафедры,  кафедры  могут  иметь  в своем
составе лаборатории. Компьютеры могут быть установлены в общих
факультетских   классах,   на   кафедрах,   в  лабораториях  и
идентифицируются  уникальными  номерами.  Во   втором   дереве
сыновьям корня соответствуют учебные корпуса, корпуса включают
списки  аудиторий,  а  для  каждой  аудитории  заданы   номера
находящихся  в  них  компьютеров.  Некоторые  аудитории  могут
принадлежать  нескольким  факультетам.  Выдать  список   таких
аудиторий (12).

   18. Трассировка  программы,   не   содержащей   рекурсивных
вызовов  и  повторяющихся  имен  процедур,  распечатана в виде
списка выполняемых процедур. Процедура попадает в список, если
к ней произошло обращение из вызывающей процедуры либо возврат
управления из  вызванной  ей  процедуры.  Структура  программы
такова,  что  каждая вызываемая процедура вложена в вызывающую
ее процедуру.  Начало и  окончание  программы  должны  быть  в
головной процедуре.  Известен объем памяти,  который требуется
для  загрузки  каждой  процедуры.  При  выходе  из   процедуры
занимаемая ей память освобождается.  Построить и выдать дерево
вызовов процедур.  Определить размер памяти,  необходимый  для
работы  программы,  и цепочку вызовов,  требующую максимальной
памяти (12).

   19. Имеется некоторое  алгебраическое выражение.  Операнды
заданы идентификаторами,  операции выполняются по приоритетам,
допускается использование круглых скобок. Возможны одноместные
операции '+' и '-', а также операция возведения в степень '^'.
Требуется построить и выдать в наглядном виде бинарное дерево,
представляющее данное выражение (12).

   20. В  листьях  И-ИЛИ  дерева,  соответствующего некоторому
множеству  конструкций,  заданы   значения   массы.   Известно
максимально допустимое значение массы изделия. Требуется усечь
дерево   так,   чтобы   дерево    включало    все    элементы,
соответствующие  допустимым  значениям массы,  но не содержало
"лишних" вершин.  Конечное дерево выдать на экран в  наглядном
виде (13).

   21. Задано   И-ИЛИ   дерево,   соответствующее   некоторому
множеству изделий. Требуется:
   1) найти число изделий,  записанное с помощью этого дерева;
   2) если  число  изделий  больше  N,  организовать  усечение
дерева  в  диалоге  в  порядке  обхода сверху вниз,  спрашивая
пользователя, какие сыновья ИЛИ-вершин отсекать и сообщая, как
при этом сокращается число изделий.
   Если усекаются  все сыновья ИЛИ-вершины,  то отсекается она
сама и все поддерево,  висящее на сыне первой  ИЛИ-вершины  по
пути к корню дерева).
   УКАЗАНИЕ: если  корни   нескольких   поддеревьев   являются
сыновьями   И-вершины,   то   общее   число   элементов  равно
произведению  числа  элементов  поддеревьев,  а   если   корни
поддеревьев  -  сыновья ИЛИ-вершины,  то общее число элементов
находится как сумма числа элементов в поддеревьях.
   Начальное и  конечное  деревья  выдать на экран в наглядном
виде (13).

   22. Информация  о  файлах  на  жестких  дисках   компьютера
записана  с  помощью  дерева.  Обеспечить выполнение следующих
операций:
   1) загрузку дерева в память из файла;
   2) обход дерева папок в  режиме  диалога  (раскрытие папок,
      подъем на уровень и т. п.); 
   3) корректировку  дерева при создании новых папок и файлов,
их переименовании, копировании, переносе и удалении. 
   4) сохранение дерева в файле (14).

   23. Имеется  И-ИЛИ   дерево,   соответствующее   некоторому
множеству  конструкций.  Требуется выдать на экран в наглядном
виде все элементы дерева (14).

   24. В офисе фирмы  Megasoft  установлены  N  компьютеров  с 
номерами от 1 до N, некоторые из них  соединены  между  собой. 
Сообщение между соединенными компьютерами проходит в любом  из 
двух направлений за 1 с. Компьютер,  получив  сообщение, сразу 
отправляет  его  всем  соединенным  с  ним  компьютерам.  Cеть 
устроена так, что между любыми двумя компьютерами  есть  путь, 
причем только один. Найти номера всех компьютеров,  с  которых 
главный программист Гилл Бейтс может отправить сообщение  так, 
чтобы максимальная задержка в  получении  сообщения  была  как 
можно меньше. 
  Ввод из файла INPUT.TXT. В первой строке вводится значение N 
(1<=N<=10^5). В каждой из следующих N-1  строк  вводится через 
пробел пара номеров компьютеров, обозначающая соединение.
  Вывод в файл OUTPUT.TXT. В первой строке выводится количество
искомых компьютеров M. Во второй строке выдаются через пробел в
порядке возрастания номера искомых компьютеров.
  Время счета не должно превышать 2 сек.
  Пример
  Ввод
4
1 2
4 3
2 3
  Вывод
2
2 3
  Указание. Предложить структуру данных, обеспечивающую быстрое
нахождение листьев бескорневого дерева из условия задачи (14).

                          2.4. Графы

   Общими требованиями к лабораторной работе являются:
   1) вводить  граф из файла в понятной для пользователя форме
(не в виде матрицы смежности, без дублирования информации и т.
п.);
   2) обеспечить   возможность   многократных   запросов   без
повторного запуска программы.

   1. На плоскости заданы координаты N  элементов,  являющихся
выводами  печатной  платы.  Некоторые  элементы  связаны между
собой.  Требуется от элемента,  имеющего наибольшую  суммарную
длину   связей   с  другими  элементами,  построить  путь,  не
содержащий циклов.  При построении пути использовать следующее
правило:  из всех возможных элементов,  связанных с данным,  в
путь включается ближайший элемент (7).

   2. На плоскости заданы координаты N  элементов,  являющихся
выводами  печатной  платы.  Некоторые  элементы  связаны между
собой.  Требуется выбрать  начальный  элемент  для  построения
пути, не содержащего циклов, максимальной длины. Путь строится
по следующему правилу:  из всех возможных элементов, связанных
с данным, в путь включается ближайший элемент (7).

   3. На плоскости заданы координаты N  элементов,  являющихся
выводами  печатной  платы.  Некоторые  элементы  связаны между
собой.  Имеются два следующие правила для построения пути,  не
содержащего циклов:
   1) из всех возможных элементов,  связанных с данным, в путь
включается ближайший элемент;
   2) из всех возможных элементов,  связанных с данным, в путь
включается  элемент,  имеющий  наибольшее  число связей с теми
элементами, которые не состоят в пути.
   Сравнить эти правила по средней длине пути при всевозможных
начальных элементах и найти наибольшие  по  пути  для  каждого
правила (7).

   4. Имеется   сеть  железных  дорог,  связывающая  различные
города.  Города принадлежат  разным  суверенным  государствам.
Каждое государство взимает значительную пошлину за въезд в его
пределы.  В  некоторых  городах  берут  дополнительный  налог.
Методом поиска в глубину найти  такой путь из пункта А в пункт
В, чтобы
   1) число   пересечений    государственных    границ    было
минимальным;
   2) среди путей,  удовлетворяющих первому условию, суммарный
налог был минимален (7).

   5. Имеется сеть автомобильных  дорог.  Известны  расстояния
всех   участков   дорог.   Некоторые  участки  аварийноопасны.
Методом поиска в глубину найти лучший путь из пункта А в пункт
В. Лучшим считается путь,  имеющий в первую очередь наименьшую
суммарную протяженность аварийноопасных,  а во  вторую очередь
наименьшую длину (7).

   6. В общежитии живет  N  студентов.  При  поселении  каждый
студент  представил список своих знакомых.  Каждое воскресение
организуется вечер знакомств,  когда знакомые любого  студента
знакомятся   между   собой.  Выяснить,  через  сколько  недель
познакомятся два указанных студента (8).

   7. Имеются  расписания вылетов самолетов в ряде аэропортов.
Требуется методом поиска в глубину по начальному  и  конечному 
пунктам   предложить    маршрут  с   возможными   пересадками, 
оптимальный по одному из следующих критериев:
   1) наименьшая суммарная стоимость билетов;
   2) минимальное число пересадок;
   3) наименьшее  время  в  пути,  включая  время  ожидания  в
аэропортах.
   При выборе маршрута считать,  что пересадка допустима, если
интервал времени между прилетом самолета и последующим вылетом
составляет не менее двух часов и не более суток (8).

   8. Имеется  информация о торговых связях предпринимателей в
виде множества пар (A,B),  где A - продавец, а B - покупатель.
Покупатели  сами являются продавцами и перепродают закупленный
товар в соответствии со своими связями с  наценкой 20 %. Задан
список    предпринимателей,    получивших   некоторый   товар.
Поиском в ширину определить такой способ получения этого товара
указанным предпринимателем, чтобы наценка была минимальной (8).

   9. Имеется  план  электрической  схемы,  заданный   графом.
Вершинами  являются  места  соединений проводов.  Каждое ребро
характеризуется некоторым сопротивлением.  На одном  из  ребер
имеется   источник   питания.  Выявить  возможности  короткого
замыкания, когда находится замкнутая цепь, включающая источник
питания  и  имеющая  суммарное  сопротивление  ниже  заданного
порога (8).

   10. Список  членов  клуба  любителей  анекдотов  включает N
человек.  Каждый из членов клуба имеет  несколько  слушателей,
которым он рассказывает анекдоты.  В клубе действуют следующие
правила:
   1) если  один человек рассказывает другому неизвестный тому
анекдот, то он получает от клуба премию 1000 рублей;
   2) если  рассказанный  анекдот  оказывается  известным,  то
рассказчик платит клубу в качестве штрафа 1000 рублей;
   3) член клуба,  узнавший на некотором заседании клуба новый
анекдот обязан на следующем заседании  пересказать  его  своим
слушателям;
   4) на каждом заседании члены клуба с  меньшими  номерами  в
списке рассказывают новые анекдоты в первую очередь;
   5) каждый член клуба рассказывает анекдот любому  из  своих
слушателей не более одного раза.
   Член клуба с номером К узнал новый анекдот и  рассказал его
своим слушателям.  Определить, какую сумму должен получить или
выплатить в конце концов каждый член клуба (8).

   11. Имеется    сеть    автомобильных   дорог,   связывающих
населенные пункты некоторого района.  Известны длины  участков
дорог  между  пунктами.  В  M пунктах производят пряжу,  в N -
перерабатывают пряжу на фабриках, а в остальных пунктах нет ни
производства,  ни  переработки.  Решено закрыть K (K<N) фабрик
переработки,   наиболее   удаленных   от   источников   сырья.
Требуется:
   1) получить список пунктов, где закрываются фабрики;
   2) для каждой из оставшихся фабрик выдать S (S<M) ближайших
пунктов, где производят пряжу (8).

   12. Реализовать алгоритм поиска кратчайших путей  Флойда  и
проиллюстрировать по шагам этапы его выполнения (8).

   13. Имеются  расписания вылетов самолетов в  ряде  аэропор-
тов.  Требуется по  начальному  и  конечному  пунктам  методом
поиска  в глубину сформировать и выдать дерево возможных путей.
Проиллюстрировать этапы поиска (9).

   14. Проект  научно-технической  программы  задан  с помощью
ориентированного графа. Вершина графа соответствует отдельному
исследованию,   а   дуги   показывают  очередность  выполнения
исследований (каждое  исследование  может  начаться  не  ранее
окончания   предшествующих   исследований).  Продолжительность
каждого исследования известна.  Задан конечный срок выполнения
проекта.  Требуется  определить  максимальный интервал времени
для проведения каждого исследования,  чтобы  проект  мог  быть
завершен к назначенному сроку (9).

   15. Реализовать алгоритм  Дейкстры  поиска  кратчайших путей 
из заданной вершины во все остальные вершины. Проиллюстрировать
по шагам этапы его выполнения. Конечные  результаты  показать в
таблице. По запросам  выдать  кратчайшие пути  с  их  длиной  в 
указанные пользователем вершины (9).

   16. В космическом центре проектируется  система организации
связи   между  спутниками,  действующая  в  реальном  масштабе
времени.  Каждый  спутник  может  иметь  либо  не  иметь   как
радиостанцию,  так и приемник радиосигналов.  Сигналы с одного
спутника могут передаваться на другие через произвольное число
промежуточных спутников.  Заранее известно, когда два спутника
появляются в зоне радиовидимости и в  течение  какого  времени
спутники  будут  находиться в этой зоне.  Требуется определить
способы возможной связи между  двумя  заданными  спутниками  в
указанный   момент   времени   в   порядке  возрастания  числа
промежуточных звеньев (9).

   17. Проект научно-технической  программы  задан  с  помощью
ориентированного графа. Вершина графа соответствует отдельному
исследованию,  а  дуги   показывают   очередность   выполнения
исследований  (каждое  исследование  может  начаться  не ранее
окончания  предшествующих   исследований).   Продолжительность
каждого исследования известна. Используя алгоритмом  Беллмана-
Форда:
   1) проверить граф на отсутствие циклов, сообщая об ошибках;
   2) найти путь наибольшей трудоемкости.
   Путем считается  последовательность  работ,  которые должны
выполняться друг за  другом.  Трудоемкость  пути  -  суммарная
продолжительность работ на этом пути (10).

   18. Найти во взвешенном  ориентированном  графе  кратчайший 
циклический  путь  из  заданной  вершины, используя   алгоритм 
Дейкстры (10).

   19. Имеется  сеть  автомобильных  дорог.  Для каждой дороги
известна максимальная масса груза, которую можно  провезти  по 
этой   дороге.   С   помощью  алгоритма  Дейкстры   определить 
максимальный   груз,   который  можно  провезти  между   двумя 
указанными городам (10).

   20. В  файле  записаны  предложения по обмену жилплощадью в
пределах некоторого города, включающие пожелания по количеству
комнат,  наличию балкона и телефона.  Имеются варианты размена
одной квартиры на 2 других либо наоборот.  Требуется по заявке
клиента  предложить способы обмена.  Предусмотреть возможность
нахождения циклических обменов, в которых участвуют более двух
сторон.  Найденные варианты выдать в порядке возрастания числа
участвующих в обмене сторон.  Считать,  что клиентам  подходят
более хорошие по сравнению с их требованиями варианты переезда
(11).

   21. Имеется  информация о взаимных долгах предприятий. Если
имеется цепочка предприятий
     A1(a1) --> A2(a2) --> ... -->An(an) --> A1(a1),
где Ai - наименование предприятия,  а ai - размер долга,  то с
каждого из предприятий можно списать долг в размере min(ai), а
предприятие с минимальным долгом исключить из списка должников
следующему в цепочке  предприятию.  Требуется  найти  варианты
взаимного списания долгов. Найденные варианты выдать в порядке
возрастания числа предприятий в циклах. Сформировать  протокол 
с указанием всех произведенных обменов (11).

   22. На диске имеется база  данных  по  физическим  эффектам
(ФЭ).  Каждый  ФЭ  записан в виде тройки компонент:  название,
входная  физическая  величина  (вход),   выходная   физическая
величина  (выход).  Имеется  не  более 50 различных физических
величин. Требуется построить в основной памяти граф связи ФЭ и
обеспечить  поиск  цепочек  ФЭ от одного до четырех звеньев по
заданным входу и выходу по возрастанию количества звеньев(12).

   23. Имеется сеть автомобильных дорог. По  некоторым дорогам
можно  проехать  только  в одном  направлении. Известна  длина 
каждой дороги, причем она может быть разной в  зависимости  от 
направления. Один  из  городов  является  столицей.  Требуется
вывести список длин вторых по минимальности путей из столицы в 
другие города. Допускается присутствие циклических путей (12).

   24. Информация  о  некотором  изделии  задана   с   помощью
ориентированного графа.  Вершина графа соответствует отдельной
операции,  а дуги показывают очередность  выполнения  операций
(каждая   операция   может   начаться   не   ранее   окончания
предшествующих операций).  Продолжительность  каждой  операции
известна.  Имеется  один  станок  для  выполнения каждого типа
операций.  Если станок освобождается,  то производится  та  из
готовых  к выполнению операций,  для которой максимальный путь
от соответствующей вершины до конца  имеет  наибольшую  длину.
Определить  время  изготовления  изделия.  Выдать общий график
выполнения операций и график загрузки каждого станка (13).

        2.5. Поиск и сортировка данных, перебор вариантов

   1. Имеется массив элементов,  отсортированный по некоторому
полю. Методом бинарного поиска обеспечить:
   1) нахождение заданного элемента;
   2) вставку элемента;
   3) удаление элемента (7).

   2. Имеется   файл   записей  с  некоторым  ключевым  полем.
Построить  в  оперативной  памяти  идеально   сбалансированное
бинарное   дерево   поиска   и   обеспечить   поиск  указанных
записей (7).

   3. Имеется  текстовый  файл  записей  с некоторым  ключевым
полем. Выполнить в оперативной памяти сортировку  вставками  с
использованием бинарного поиска (7).

   4. Имеется массив целых чисел. Отсортировать его  на  месте
методом шейкер-сортировки. Удалить повторное вхождение  чисел,
не используя дополнительной памяти (8). 

   5. В текстовом файле задана последовательность целых чисел.
Отсортировать файл  методом  простого  слияния  с  4  лентами. 
Удалить повторное вхождение чисел, не используя дополнительной 
памяти (8).

   6. Составить  программу  хеширования  массива с разрешением
коллизий методом цепочек. Обеспечить поиск и удаление записи с
заданным ключом (8).

   7. В текстовом файле задана последовательность целых чисел.
Отсортировать файл методом естественного  слияния с 4 лентами. 
Удалить повторное вхождение чисел, не используя дополнительной 
памяти (9).

   8. Имеется  текстовый  файл  записей  с некоторым  ключевым
полем. Выполнить в оперативной памяти турнирную сортировку (9).

   9. Имеется  текстовый  файл  записей  с некоторым  ключевым
полем.  Отсортировать файл путем совмещения методов внутренней
и внешней сортировок (10).

   10. Имеется  текстовый файл  записей  с  некоторым  ключевым
полем.  Отсортировать файл методом сбалансированного слияния с
3 лентами (10).

   11. Реализовать  эвристический   алгоритм   решения  задачи
коммивояжера на неориентированном полном  графе  на  основании 
метода  Прима  нахождения  остовного дерева. Проиллюстрировать
по шагам этапы поиска (11).

   12. Реализовать  эвристический   алгоритм   решения  задачи
коммивояжера на неориентированном полном  графе  на  основании 
метода Краскала нахождения остовного дерева. Проиллюстрировать
по шагам этапы поиска (11).

   13. В файле имеется телефонный справочник,  включающий имена
владельцев телефонов.  Организовать быстрый поиск  по  номерам
телефонов   с   помощью   хеширования.  Обеспечить  дополнение
и удаление записей справочника (11).

   14. В   файле   имеется  информация   о   торговых   связях 
предпринимателей в виде множества пар (A,B), где A - продавец,
а B - покупатель. Общее число предпринимателей не  ограничено.
Часть продавцов являются производителями товаров, а  остальные
перепродают закупленный товар. По новому постановлению,  лица,
перепродающие  товары,  объявлены  спекулянтами.  Требуется на
основе  хеширования  сформировать файл-справочник для быстрого
ответа  на  вопрос,  является  ли   указанный  предприниматель 
продавцом,  покупателем или спекулянтом (11).

   15. При  заданном  четном  N  (N  <=  16)  перечислить  все
правильные скобочные формы длины N из скобок '(', ')', '[',']'. 
Время счета не более 1 сек (11).
Например, для N=4  правильные формы:
(())
([])
()()
()[]
[()]
[[]]
[]()
[][]

   16. Дана  шахматная  доска,  состоящая   из   NxN   клеток,
несколько из них занято другими фигурами.  Провести ходом коня
через незанятые клетки путь  минимальной  длины  из  начальной
клетки в конечную.
   Ограничения: 2 <= N <= 500, время 1 с.
   Ввод из файла input.txt. В  первой строке задано число N. В
следующих  N  строках  содержится  по  N символов.  Символом #
обозначена занятая клетка,  точкой -  незанятая  клетка,  @  -
исходное и конечное положение коня (таких символов два).
   Вывод в файл output.txt.  Если  путь построить  невозможно,
вывести No,  в противном случае вывести такую же карту,  как и
на входе, но пометить символом @  все промежуточные  положения 
коня (11).
Примеры
Ввод 1    Ввод 2    Ввод 3
5         5         5
.....     @..@.     @....
.@@..     ..##.     ..#..
.....     .....     .#...
.....     .....     .....
.....     .....     ....@
Вывод 1   Вывод 2   Вывод 3
...@.     @..@.     No
.@@..     ..##.
....@     .@..@
.....     ..@..
.....     @....

   17. Дана  шахматная  доска,  состоящая   из   NxN   клеток,
несколько из них занято другими фигурами. Провести ходом ладьи
через незанятые клетки путь  минимальной  длины  из  начальной
клетки в конечную.
   Ограничения: 2 <= N <= 500, время 1 с.
   Ввод из файла input.txt. В  первой строке задано число N. В
следующих  N  строках  содержится  по  N символов.  Символом #
обозначена занятая клетка,  точкой -  незанятая  клетка,  @  -
исходное и конечное положение ладьи (таких символов два).
   Вывод в файл output.txt.  Если  путь построить  невозможно,
вывести No,  в противном случае вывести такую же карту,  как и
на входе, но пометить символом @  все промежуточные  положения 
коня (11).
Примеры
Ввод 1    Ввод 2    Ввод 3
5         5         5
.....     @....     @...#
.@@..     ..##.     ..#..
.....     #...#     .#.##
.....     ..#..     #....
.....     #..#@     ....@
Вывод 1   Вывод 2   Вывод 3
.....     @....     No
.@@..     @@##.     
.....     #@@@#     
.....     ..#@@     
.....     #..#@     

   18. На  шахматном поле расположены N черных  и  одна  белая 
шашка.  Требуется  написать  программу, которая  по  заданному 
расположению шашек определяет, какое  максимальное  количество
шашек может взять белая шашка за один ход. Взятая  шашка сразу
снимается с доски. 
   Ввод из файла INPUT.TXT. Задается 8 строк, каждая  содержит
8 символов. Символом ‘0’ обозначается пустая клетка,  символом
‘1’ положение черной шашки и символом ‘2’ положение белой шашки.
   Вывод  в  файл  OUTPUT.TXT.  Вывести  единственное  число – 
максимальное количество черных шашек, которых можно  взять  за 
один ход (11).
   Пример
   Ввод
00010101
00000000
01010100
00000000
01010100
00000000
01010100
20000000
   Вывод 
9

   19. Имеется N костей игры домино. На каждой кости имеется 2 
числа (каждое от 0 до 6). Кости могут повторяться. Требуется написать
программу, которая будет определять максимальное число, составленное
из цифр на костях цепочки, составленной по правилам домино из
имеющихся костей. Время счета до 1 с.
   Ввод. Первая строка входного файла содержит целое число N – 
количество костей (2 <= N <= 15). Следующие N строк содержат 2
целых числа X и Y (0 <= X, Y <= 6), разделенные пробелом.
   Вывод. В выходной файл необходимо вывести максимальное целое
число, цифры которого соответствуют значению костей в цепочке(11).
   Примеры
Ввод 1         Ввод 2         Ввод 3
3              2              5
1 6            6 6            1 5
0 0            3 6            3 4
2 5                           4 1
                              1 6
                              1 0
Вывод 1        Вывод 2        Вывод 3
61             6663           611443

   20. Составить   программу  поиска  записи  с  включением  в 
сильно   ветвящемся   Б-дереве   порядка  N.  Б-дерево  должно 
храниться и обрабатываться в файле с прямым доступом (12).

         3. ОФОРМЛЕНИЕ И ПОРЯДОК КОНТРОЛЯ РЕЗУЛЬТАТОВ

   Конечным результатом  выполнения каждой лабораторной работы
является отлаженная программа и набор тестов.  Текст программы
представляется  на   машинных   носителях  и  должен  включать 
постановку задачи, сведения об авторе и подробные комментарии.
   После выполнения    лабораторной    работы    преподаватель
проверяет   качество   оформления   текста   и    правильность
функционирования программы сначала на тестах автора, а затем и
на др4угих данных.
   Преподаватель вправе   задать   вопросы   по   всем  частям
программы,  поэтому качественное документирование способствует
успешной защите работы.

                  4. ПРИМЕРЫ РЕШАЕМЫХ ЗАДАЧ

   В настоящем  разделе  описываются  пять  примеров  по темам
лабораторных работ.
   В примерах   не   ставилась   задача  обеспечения  удобного
интерфейса с пользователем.  Для этих целей можно  высвечивать
информацию  в  выделенных  на  экране  окнах,  в режиме "меню"
спрашивать  пользователя  о   его   намерениях,   организовать
начальную   заставку   с  информацией  о  программе,  добавить
элементы звукового сопровождения и т. п.

                     4.1. Текстовые файлы

   Дан текстовый файл,  в котором возможны  переносы  слов  со
строки  на  строку.  Подсчитать  общее  число слов.  Имя файла
задать в командной строке.

Program Word;
  Var
    f: text;              { исходный файл }
    name: string[20];     { для имени файла }
    s:    string;    { очередная строка файла }
    m,n,i,kol: integer;
    b: boolean;

  Procedure Soob(mess: string);
    Begin
      Writeln(mess);
      Readln;   { пауза }
      Halt      { конец }
    End;

  Begin  { основная программа }
    if ParamCount<1 then Soob('Не указан исходный файл')
      { в командной строке нет параметров }
    else Assign(f,ParamStr(1));
    name:=ParamStr(1);
    {$I-}     { отключение прерывания при ошибке ввода }
    Reset(f);
    {$I+}     { восстановление системной реакции на ошибку }
    if IoResult<>0 then Soob('Ошибка открытия файла '+name);
    kol:=0;
    While not eof(f) do
      begin
        Readln(f,s);
        m:=Length(s);  { длина  очередной строки }
        n:=1;   b:=true;
        While b do
          Begin
            While (s[n]=' ') and (n<=m) do n:=n+1;
              { пропуск пробелов }
            While (s[n]<>' ') and (n<=m) do n:=n+1;
              { очередное слово }
            if (s[n-1]<>'-') and (s[n-1]<>' ') and (m>0)
        { не пустая строка, нет переноса и пробелов в конце }
              then kol:=kol+1;
            if n>m then b:=false  { признак выхода из цикла }
          end
      end;
      Writeln('Количество слов ',kol);
      Readln        { заключительная пауза }
  End.

                     4.2. Линейные списки

   Составить программу    работы   с   циклической   очередью,
организованной с помощью структуры с  указателями.  Обеспечить
операции постановки в очередь,  продвижения очереди, вставки в
середину перед элементом  с  заданным  ключом  и  удаления  из
середины.

Program CiclList;
Uses crt;
Type  Ukaz = ^List;
      List = Record
               Key  : Integer;
               Next : Ukaz;
             End;
{      кольцевая очередь; указатели от начала к концу        }

{      конечный элемент замыкается на начало                 }
Var   p,q,r : Ukaz;  { r - указатель на конечный элемент     }
      Knew,k,tmp,CouElem : Integer;
{      CouElem - число элементов в очереди                   }
{------------------------------------------------------------}
{                   Постановка в очередь                     }
{------------------------------------------------------------}
Procedure MakeList;
Begin
  While True Do
    Begin
      Write('Ключ : ');
      ReadLn(Knew);
      If Knew = 0 Then
        Begin
          WriteLn('Всего элементов: ',CouElem);
          Exit
        End;
      New(q);
      If CouElem=0 Then
        q^.next :=q   { первый элемент указывает сам на себя }
      Else
        Begin
          q^.next:=r^.next;     { r^.next --> начало очереди }
          r^.next := q      { связь с бывшим концом очереди  }
        End;
      q^.key := Knew;
      r:=q;                  { новый элемент - конец очереди }
      Inc(CouElem);
    End
End;
{------------------------------------------------------------}
{                   Продвижение очереди                      }
{------------------------------------------------------------}
Procedure Go;
Var    Count : Integer;
Begin

  p:=r^.next;                  { указатель на начало очереди }
  WriteLn('Ключ начальной позиции ',p^.key);
  Dec(CouElem);
  If CouElem>0 Then
    begin
      q:=p^.next;             { второй элемент }
      r^.next:=q;
      WriteLn('Ключ новой начальной позиции ',q^.key)
    end
  Else WriteLn('Очередь пуста');
  Dispose(p)
End;
{------------------------------------------------------------}
{    Вставка в середину перед элементом с заданным ключом    }
{------------------------------------------------------------}
Procedure IncList;
Var c : Integer;
    g : Ukaz;
Begin
  c:=0;
  Write('Перед элементом с ключом ');
  ReadLn(k);
  p:=r^.next;                 { начало очереди }
  Repeat
    If p^.key = k Then        { ищем элемент с нужным ключом }
      Begin
        New(g);               { и вставляем перед ним новый  }
        g^:=p^;
        p^.next := g;
        Write('Ключ : ');
        ReadLn(Knew);
        If Knew = 0 Then Exit;
        p^.key:=Knew;
        If c=CouElem-1 Then r:=g; {  вставка перед концом    }
        Inc(CouElem);
        Exit
      End

    Else
      Begin
         p := p^.next;    {  продвинуться по очереди         }
         Inc(c)
      End
  Until c=CouElem;     { цикл до возврата в исходную позицию }
  WriteLn('В списке элемента с ключом ',k,' нет')
End;
{------------------------------------------------------------}
{              Удаление из середины очереди                  }
{------------------------------------------------------------}
Procedure DelFromList;
Var c :  Integer;
Begin
  c:=0;
  Write('С каким ключом ? ');
  ReadLn(k);
  p:=r^.next;           { начало очереди }
  Repeat
    If p^.key = k Then
      Begin                  { ищем элемент с нужным ключом  }
        If p = r^.next Then Go { удаление из начала очереди  }
        Else
          Begin
            q^.next := p^.next;
            If p=r Then  r:=q;   {   конец очереди           }
            Dispose(p);
            Dec(CouElem);
          End;
        Exit
      End
    Else
      Begin
         q:=p;            {  запомнить предыдущий элемент   }
         p := p^.next;    {  продвинуться по очереди        }
         Inc(c)
      End

  Until c=CouElem;    { цикл до возврата в исходную позицию }
  WriteLn('В списке элемента с ключом ',k,' нет')
End;

{------------------------------------------------------------}
{                Выдача очереди на экран                     }
{------------------------------------------------------------}
Procedure OutList;
Var Count,i : Integer;
Begin
  p:=r^.next;                     { начало очереди }
  For i:=1 To CouElem Do
    begin
      Write(p^.key,' ');
      p:=p^.next
    end;
  WriteLn;
  WriteLn('Всего элементов: ',CouElem)
End;
{------------------------------------------------------------}
{                   Головная программа                       }
{------------------------------------------------------------}
Begin
  Clrscr;
  CouElem:=0;            { счетчик числа элементов в очереди }
  Repeat
    Writeln;
    WriteLn('1.Поставить в очередь (ключ 0-признак конца)');
    WriteLn('2.Продвинуть очередь');
    WriteLn('3.Вставить элемент');
    WriteLn('4.Удалить элемент');
    WriteLn('5.Показать всю очередь');
    WriteLn('6.Выход');
    Write('Выбираем : ');
    ReadLn(Tmp);         {  номер пункта меню }
    Case Tmp Of
      1 : MakeList;
      2 : If CouElem <> 0 Then Go
          Else WriteLn('Очереди нет, повторите выбор');
      3 : If CouElem <> 0 Then IncList
          Else WriteLn('Очереди нет, повторите выбор');
      4 : If CouElem <> 0 Then DelFromList
          Else WriteLn('Очереди нет, повторите выбор');
      5 : If CouElem <> 0 Then OutList
          Else WriteLn('Очередь пуста');
      6 : Halt
    End
  Until False
End.

                         4.3. Деревья

   В листьях    бинарного    дерева    указаны    цифры   либо
идентификаторы  переменных,  заданные   строчными   латинскими
буквами,  в  других  вершинах - знаки арифметических операций.
Значения переменных известны.  Выдать  на  экран  выражение  в
префиксной   и   постфиксной   формах.   Определить   значение
выражения.

Program TreeCount;
  Uses crt;
  Const
    zn= ['+','-','/','*','^'];
    let=['a'..'z'];          { буквы }
    dig=['0'..'9'];          { цифры }
    smv=zn+let+dig;          { допустимые символы при вводе }
  Type
    ukaz=^uzel;
    uzel=record              { структура вершины дерева }
           key:char ;        { знак, цифра или буква    }
           left,right:ukaz   { сыновья                  }
         end;
  Var
    root,kon:    ukaz;
    a:           array ['a'..'z'] of real;
    { массив значений идентификаторов дерева }
    s:           set of char;  { множество введенных букв }
    n,k:         char;
  Procedure Sozd(t:ukaz);
    { рекурсивная процедура создания исходного дерева }
    { t-указатель на корень }
    Begin
      if t<>nil then
        begin
          Repeat
            Write('Введите значение вершины ');
            Readln(k);
            if not (k in smv) then
              Writeln('Неправильный символ, повторите ввод ');
          Until k in smv;
          t^.key:=k;
          if not (k in zn) then  { k-буква или цифра }
            begin
              t^.left:=nil;
              t^.right:=nil;
              if k in let then   { k-буква }
                s:=s+[k]         { добавление в множество }
            end
          else
            begin
              Writeln('Переходим к левому сыну вершины ',
                       t^.key);
              New(kon);
              t^.left:=kon
            end;
          Sozd  (t^.left);
          if t^.left<>nil then   { t^.key-буква или цифра }
            begin
              Writeln('Переходим к правому сыну вершины ',
                       t^.key);
              New(kon);
              t^.right:=kon
            end;
          Sozd(t^.right)
        end
    End;
  Procedure PechPo(t:ukaz);
  { вывод на экран выражения в постфиксной форме }
  Begin
    if t<>nil then
      begin
        PechPo(t^.left);
        PechPo(t^.right);
        Write(t^.key,' ')
      end
  End;
  Procedure PechPr(t:ukaz);
  { вывод на экран выражения в префиксной форме }
  Begin
    if t<>nil then
    begin
      Write(t^.key,' ');
      PechPr(t^.left);
      PechPr(t^.right)
   end
  End;
  Function f1(t:ukaz):real;
  { расчет значения выражения, заданного бинарным деревом }
  Begin
    if t^.left=nil then     { лист: в t^.key цифра или буква }
      if t^.key in dig then        { цифра }
        f1:=ord(t^.key)-ord('0')   { числовое значение }
      else                         { буква-идентификатор }
        f1:=a[t^.key]              { значение идентификатора }
    else case t^.key of            { не лист: в t^.key знак }
            '+': f1:=f1(t^.left)+f1(t^.right);
            '-': f1:=f1(t^.left)-f1(t^.right);
            '*': f1:=f1(t^.left)*f1(t^.right);
            '/': f1:=f1(t^.left)/f1(t^.right);
            '^': f1:=exp(f1(t^.right)*ln(f1(t^.left)))
         end
  End;
  Begin
    s:=[];          { пустое множество }
    Clrscr;
    New(root);
    Sozd  (root);
    Writeln('Ввод закончен !');
    Readln;   { пауза }
    PechPo(root);
    Writeln('   - постфиксная форма');
    Readln;
    PechPr(root);
    Writeln('   - префиксная форма');
    Readln;
    For n:='a' to 'z' do  { ввод значений идентификаторов }
      if n in s then
        begin
          Write (n,'=');
          Readln(a[n]);
        end;
    Writeln('Значение выражения:  ', f1(root):1:3);
    Readln
  End.

                          4.4. Графы

   Имеется сеть междугородных  автомобильных  дорог.  Известны
расстояния  всех  участков  дорог.  Требуется  перечислить все
пути,  ведущие из пункта А в пункт  В,  не  проходящие  дважды
через один и тот же пункт.

Program Puti;
  { перечисление путей на графе }
  Uses crt;
  Const
    max=10;
  Type
    mat=array[1..max,1..max] of integer; { матрица смежности }
    put=1..max;       { номер вершины в пути }
  Var
    matr : mat;
    m: set of put;    { множество вершин, входящих в путь }
    gr: array [1..max] of integer; { текущий путь }
    a,b,versh,k,j,i: integer;
    l: boolean;
    ch: char;
  Procedure WwodMatr(var matr: mat);
    { ввод матрицы смежности }
    Begin
      TextBackGround(Black);
      TextColor(White);
      Clrscr;
      Write('Введите количество пунктов:  ');
      Readln(versh);
      For i:=1 to versh do
        For j:=1 to versh do
          begin
            matr[i,j]:=0;
            matr[j,i]:=0
          end;
      Repeat
        Write('Введите связи в виде пары вершин (99-конец) ');
        Read(i);
        if i<>99 then Read(j);
        if (i>0) and (i<=versh) and (j>0) and (j<=versh) then
          begin
            matr[i,j]:=1;
            matr[j,i]:=1   { матрица смежности симметрична }
          end
        else if i<>99 then Writeln('Ошибка ввода ')
      Until i=99;
      Writeln('Ввод закончен !');
      Writeln;
      Readln    { пауза }
    End;
  Procedure Wiwod(matr: mat);
    Begin
      Window(46,2,75,22);         { окно вывода результатов }
      TextBackGround(Cyan);
      Clrscr;
      TextColor(LightGreen);
      Write('  ');
      For i:=1 to versh do
        Write(i:2);               { номера столбцов матрицы }
      Writeln;
      For i:=1 to versh do
        begin
          TextColor(LightGreen);
          Write(i:2);             { номера строк матрицы }
          TextColor(White);
          For j:=1 to versh do
            Write(matr[i,j]:2);
          Writeln
        end
     End;
   Procedure PoiskPut(t: integer);
   { поиск всех путей на графе }
     Var i: integer;
     Begin
       gr[j]:=t; { добавление в путь текущей вершины }
       m:=m+[t]; { коррекция множества вершин пути   }
       j:=j+1;
       if t=b then  { b-конечная вершина }
         begin
           Write('Найден путь:  ');
           For i:=1 to j-1 do       { вывод пути }
             Write(gr[i],'  ');
           Writeln;
           Readln    { пауза }
         end
       else
         For i:=1 to versh do
           if not (i in m) and (matr[t,i]=1) then
    { поиск в глубину: выбор продолжения пути без цикла  }
             PoiskPut(i);
    { здесь оказываемся после нахождения очередного пути }
    { или в случае попадания в тупик                     }
       m:=m-[t];
    { исключение из множества вершин пути последней вершины }
       j:=j-1      { возврат в предыдущую вершину }
     End;
   Begin             { основная программа }
     Clrscr;         { очистка экрана     }
     WwodMatr(matr); { ввод матрицы смежности }
     l:=true;
     While l do
       begin
         Wiwod(matr);
         Writeln;
         Write('Введите исходный пункт A:  ');
         Readln(a);
         Write('Введите конечный пункт B:  ');
         Readln(b);
         Writeln;
         j:=1;
         m:=[];        { инициализация множества вершин пути }
         PoiskPut(a);  { перечисление всех путей             }
         Writeln('Путей больше нет ! ');
         Write('Повторить поиск[д/н] ? ');
         Readln(ch);
         if ch='н' then l:=false   { для выхода из цикла }
       end
   End.

                4.5. Поиск и сортировка данных

   Определить среднее   число   проб   при   поиске    записей
хешированного  массива  (квадратичная  проба) в зависимости от
коэффициента заполнения таблицы.

Program Heshirov;
Uses CRT;
Const
  M=977;        { простое число }
  M1=M-1;       {   M1=M-1      }
  LIM=500;      {   число попыток размещения в таблице }
  NUMTIME=20;   { число опытов }
Type
  field=record
          key:word;     { ключ размещаемой записи }
          flag:boolean  { TRUE - место в таблице свободно }
        end;
  tsize=0..M1;
  table=array [tsize] of field;
  result=array[ 0..100] of real;
Var
  t:table;               { заполняемая таблица }
  h:tsize;               { индекс в таблице    }
  i,j,a,k,n: word;
  r:result;              { результаты по процентам }
Begin
  TextBackground(3);
  ClrScr;
  TextColor(14);
  TextBackground(0);
  GoToXY(35,3);
  Writeln('ХЕШИРОВАНИЕ');
  TextColor(11);                { цвет символов }
  TextBackground(0);            { цвет фона }
  GoToXY(6,4);
  Write('Зависимость числа квадратичных проб от коэффициента',
        ' заполнения таблицы');
  For a:=0 to 100 do
    r[a]:=0;
  For j:=1 to NUMTIME do
    begin
      n:=0;          { счетчик числа удачных размещений }
      For h:=0 to M1 do  { очистка таблицы }
        t[h].flag:=TRUE;
      Randomize;   { случайная инициализация для Random }
      Repeat
        i:=0;
        k:=Random(64000);  { случайный ключ }
        h:=k mod M;        { приведение в диапазон 0-M1 }
        While not (t[h].flag) and (t[h].key<>k) and (i<LIM)) do
          { пока не найдено свободное место  }
          begin
            Inc(i);
            h:=(k+i*i)mod M
          end;
        if t[h].key<>k then    { найдено свободное место }
           begin
             Inc(n);
             t[h].key:=k;
             t[h].flag:=FALSE  { признак заполнения }
           end;
        a:=Round(n/M*100);     { процент заполнения таблицы }
        r[a]:=(r[a]*(j-1)+i+1)/j
        { среднее число попыток для этого процента; здесь:   }
        { r[a]*(j-1) - общее число предыдущих попыток,       }
        { i+1 - число попыток при заполнении текущей таблицы }
      Until a>=95          { заполнение таблицы идет до 95 % }
    end;
    TextColor(13);
    TextBackground(1);
    GoToXY(1,10);               { начало строки 10 }
    { выдача рамки таблицы с результатами }
    Write('-');
    For i:=1 to 19 do
      if r[5*i]>10 then Write('----T')
      else Write('---T');
    Write(#8,'¬');     { #8 - возврат назад на 1 позицию }
    GoToXY(1,12);
    Write('+');
    For i:=1 to 19 do
      if r[5*i]>10 then Write('----+')
      else Write('---+');
    Write(#8,'+');
    GoToXY(1,11);
    Write('¦');
    GoToXY(1,13);
    Write('¦');
    { заполнение строки процентов (от 5 до 95 с шагом 5) }
    GoToXY(2,11);
    For i:=1 to 19 do
      if r[5*i]>10 then Write(' ',5*i:2,'%¦')
      else Write(5*i:2,'%¦');      { конечные результаты }
    GoToXY(2,13);
    For i:=1 to 19 do
      if r[5*i]>10 then Write(r[5*i]:4:1,'¦')
      else Write(r[5*i]:3:1,'¦');
    { завершение прорисовки рамки }
    GoToXY(1,14);
    Write('L');
    For i:=1 to 19 do
      if r[5*i]>10 then Write('----+')
      else Write('---+');
    Write(#8,'-');
    TextColor(10);
    TextBackground(4);
    GoToXY(4,23);
    Write('Press any key...');
    Repeat
    Until KeyPressed   { ожидание до нажатия клавиши }
  End.
